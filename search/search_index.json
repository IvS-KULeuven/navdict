{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"An intelligent navigable dictionary","text":"<p>\ud83d\udea7\u2013 WIP \u2013 this is an early version of a project in development. Please use it  and fork it and create issues and feature requests.</p> <p>This module defines the NavigableDict (aka. <code>navdict</code>), which is a dictionary that is dot-navigable and has some special features to autoload files.</p> <p>The information that is in the NavigableDict can be navigated in two different ways. First, the navdict is a dictionary, so all information can be accessed by keys as in the following example.</p> <pre><code>&gt;&gt;&gt; setup = NavigableDict({\"gse\": {\"hexapod\": {\"ID\": 42, \"calibration\": [0,1,2,3,4,5]}}})\n&gt;&gt;&gt; setup[\"gse\"][\"hexapod\"][\"ID\"]\n42\n</code></pre> <p>Second, each of the keys is also available as an attribute of the NavigableDict and that makes it possible to navigate the navdict with dot-notation:</p> <pre><code>&gt;&gt;&gt; id = setup.gse.hexapod.ID\n</code></pre> <p>If you want to know which keys you can use to navigate the navdict, use the <code>keys()</code> method.</p> <pre><code>&gt;&gt;&gt; setup.gse.hexapod.keys()\ndict_keys(['ID', 'calibration'])\n&gt;&gt;&gt; setup.gse.hexapod.calibration\n[0, 1, 2, 3, 4, 5]\n</code></pre> <p>To get a full printout of the navdict, you can use the print method from the rich package. Be careful, because this can print out a lot of information when a full configuration is loaded.</p> <pre><code>&gt;&gt;&gt; from rich import print\n&gt;&gt;&gt; print(setup)\nNavigableDict\n\u2514\u2500\u2500 gse\n    \u2514\u2500\u2500 hexapod\n        \u251c\u2500\u2500 ID: 42\n        \u2514\u2500\u2500 calibration: [0, 1, 2, 3, 4, 5]\n</code></pre>"},{"location":"#special-values","title":"Special Values","text":"<p>Some of the information in the navdict is interpreted in a special way, i.e. some values are processed before returning. Examples are the classes and calibration/data files. The following values are treated special if they start with:</p> <ul> <li><code>class//</code>: instantiate the class and return the object</li> <li><code>factory//</code>: instantiates a factory and executes its <code>create()</code> method</li> <li><code>csv//</code>: load the CSV file and return a numpy array</li> <li><code>yaml//</code>: load the YAML file and return a dictionary</li> <li><code>int-enum//</code>: dynamically create the enumeration and return the Enum object</li> </ul> <p>We call these values directives and they are explained in more detail in  How directives work.</p>"},{"location":"#data-files","title":"Data Files","text":"<p>Some information is too large to add to the navdict as such and should be loaded from a data file. Examples are calibration files, flat-fields, temperature conversion curves, etc.</p> <p>The navdict will automatically load the file when you access a key that  contains a value that starts with <code>csv//</code> or <code>yaml//</code>.</p> <pre><code>&gt;&gt;&gt; setup = navdict({\n...     \"instrument\": {\"coeff\": \"csv//cal_coeff_1234.csv\"}\n... })\n&gt;&gt;&gt; setup.instrument.coeff[0, 4]\n5.0\n</code></pre> <p>Note: the resource location is always relative to the current location XXXX </p>"},{"location":"directives/","title":"How directives work","text":""},{"location":"directives/#what-are-directives","title":"What are directives?","text":"<p>Directives are instructions in a YAML file that are interpreted by the  <code>NavigableDict</code> whenever the value containing the directive is accessed.  Let's explain this with an example. We have a simple YAML file (`setup.yaml)  with the following content:</p> <p><pre><code>Setup:\n    project_info: yaml//project_info.yaml\n</code></pre> This short YAML string contains a directive <code>yaml//</code> which will load the  <code>project_info.yaml</code> file whenever the <code>project_info</code> key is accessed. </p> <p>The <code>project_info.yaml</code> file contains the following keys:</p> <p><pre><code>project: navdict\nversion: 0.3.2\n</code></pre> Assume both YAML files are located in your HOME folder.</p> <pre><code>&gt;&gt;&gt; from navdict import NavDict\n\n&gt;&gt;&gt; setup = NavDict.from_yaml_file(\"~/setup.yaml\")\n&gt;&gt;&gt; print(setup)\nSetup:\n    project_info: yaml//project_info.yaml\n&gt;&gt;&gt; print(setup.Setup)\nproject_info: yaml//project_info.yaml\n&gt;&gt;&gt; print(setup.Setup.project_info)\nproject: navdict\nversion: 0.3.2\n</code></pre>"},{"location":"directives/#matching-directives","title":"Matching directives","text":"<p>A value containing a directive shall match against the following regular  expression:</p> <p>The value is a string matching <code>r\"^([a-zA-Z]\\w+)[\\/]{2}(.*)$\"</code> where:</p> <ul> <li>group 1 is the directive key and </li> <li>group 2 is the directive value that is passed into the function that is    associated with the directive.</li> </ul> <p>For example, the value 'yaml//config.yaml' will match and group 1 is 'yaml'  and group 2 is 'config.yaml'.</p> <p>The function <code>unravel_directive(...) -&gt; tuple[str, str]</code> parses the  directive and returns the two groups as a tuple. This happens under the hood  and should not bother you unless you are a navdict developer \ud83e\uddd0</p>"},{"location":"directives/#default-directives","title":"Default directives","text":"<p>The <code>navdict</code> project has defined the following directives:</p> <ul> <li><code>class//</code>: instantiate the class and return the object</li> <li><code>factory//</code>: instantiates a factory and executes its <code>create()</code> method</li> <li><code>csv//</code>: load the CSV file and return a numpy array</li> <li><code>yaml//</code>: load the YAML file and return a dictionary</li> <li><code>int-enum//</code>: dynamically create the enumeration and return the Enum object</li> </ul>"},{"location":"directives/#filenames","title":"Filenames","text":"<p>When the directive value is a filename or path, it can be absolute or  relative. An absolute filename is used as-is and passed to the directive  function. A relative filename is interpreted as follows:</p> <ul> <li>when the parent \u2014which should be a NavDict\u2014 contains a <code>_filename</code>    attribute, the value of the directive is interpreted relative to the    location of the parent.</li> <li>when the parent doesn't have a <code>_filename</code> attribute or if it is <code>None</code>,    the directive value is relative to the current working directory.</li> </ul>"},{"location":"directives/#custom-directives","title":"Custom directives","text":"<p>If you have special needs to handle directives in your YAML files, you can  implement your own directive as a plugin. What you need is a unique name for  the directive and a function to handle and process the data.</p> <p>The builtin directives <code>yaml//</code> and <code>csv//</code> are implemented as a plugin and  can serve as an example for your directive plugin.</p> <p>In the <code>pyproject.toml</code> file of your project, you should add an entrypoint  for your directive plugin. As an example, taken from the navdict project:</p> <pre><code>[project.entry-points.\"navdict.directive\"]\nyaml = 'navdict.directives:load_yaml'\ncsv = 'navdict.directives:load_csv'\n</code></pre> <p>The functions that you define to handle the directive shall have the  following interface definition. The example is from the builtin <code>yaml</code>  directive.</p> <pre><code>def load_yaml(value: str, parent_location: Path | None, *args, **kwargs):\n    ...\n</code></pre> <p>The <code>value</code> is the part of the directive that comes after the double slashes  '//'. This might be a filename or path, or any other string that your  directive needs for processing. </p> <p>The <code>parent_location</code> is the location of the YAML file that was used to load  the navdict. You can use this location to determine the full path of a  resource that you need for processing the directive. For example, if the  <code>value</code> contains a filename and a relative path, the <code>parent_location</code> can  be used as the root for this relative path. The builtin directives use a  function <code>get_resource_location(...)</code> to determine the full path of the  resource to be loaded, e.g.</p> <pre><code>from navdict.navdict import get_resource_location\n\nyaml_location = get_resource_location(parent_location, relative_path)\n</code></pre> <p>The <code>args</code> and <code>kwargs</code> are entries from the YAML file that are passed into  the directive function without processing. The <code>args</code> are determined from  the YAML field <code>&lt;key&gt;_args</code> and the <code>kwargs</code> from <code>&lt;key&gt;_kwargs</code>. For  example, the <code>csv</code> directive can take a keyword argument <code>header_rows</code> to  parse and skip a number of rows in the CSV file. The YAML file would look  something like this:</p> <pre><code>setup:\n    hk_metrics: csv//data/hk_metrics_daq.csv\n    hk_metrics_kwargs:\n        header_rows: 2\n</code></pre> <p>This will pass <code>header_rows=2</code> as a keyword argument into the <code>load_csv()</code>  directive function.</p>"},{"location":"roadmap/","title":"Roadmap","text":"<p>Don't worry, the feature set will grow ...</p>"},{"location":"roadmap/#features","title":"Features","text":"<ul> <li> <p> the <code>csv//</code> directive might be improved with specification of the    number of rows that a header takes up, that might need to go into a field,    e.g. <code>args</code> below and at the same level as where the directive is.</p> </li> <li> <p> Add pluggable functionality to NavDict to do something like  <code>bad_pixels//&lt;filename&gt;.fits</code> and this will then execute a function that    takes the <code>&lt;filename&gt;.fits</code> as an argument. That function can return a    filename or a file descriptor, or a FITS object....</p> </li> </ul>"}]}